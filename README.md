# IsoMesh
IsoMesh is a group of related tools for Unity for converting meshes into signed distance field data, raymarching signed distance fields, and extracting signed distance field data back to meshes via surface nets or dual contouring. All the work is parallelized on the GPU using compute shaders.

My motivation for making this was simple: I want to make a game in which I morph and manipulate meshes, and this seemed like the right technique for the job. Isosurface extraction is most often used for stuff like terrain manipulation. Check out No Man's Sky, for example.

I decided to share my code here because it represents a lot of trial and error and research on my part. And frankly, I just think it's cool.

![isomesh2](https://user-images.githubusercontent.com/18707147/115974497-2070d200-a555-11eb-85cd-cfffed99c771.png)


## Signed Distance Fields
A signed distance field, or 'SDF', is a function which takes a position in space and returns the distance from that point to the surface of an object. The distance is negative if the point is inside the object. These functions can be used to represent all sorts of groovy shapes, and are in some sense 'volumetric', as opposed to the more traditional polygon-based way of representing geometry.

If you're unfamiliar with SDFs, I would be remiss if I didn't point you to the great [Inigo Quilez](https://www.iquilezles.org/). I'm sure his stuff will do a much better job explaining it than I could.

### Signed Distance Fields + Meshes
While SDFs are really handy, they're mostly good for representing primitive shapes like spheres, cuboids, cones, etc. You can make some pretty impressive stuff just by combining and apply transformations to those forms, but for this project I wanted to try combine the mushy goodness of SDFs with the versatility of triangle meshes. I do this by sampling points in a bounding box around a mesh, and then interpolating the in-between bits.

#### Adding Meshes
In order to add a mesh of your own, open Tools > 'Mesh to SDF'. Give it a mesh reference and select a sample size, I suggest 64. Remember this is cubic, so the workload and resulting file size increases very quickly. If your mesh has UVs you can sample those too.

There is also the option to tessellate the mesh before creating the SDF. This will take time and increase the GPU workload, but it will not alter the size of the resulting file. The advantage of the tessellation step is that the resulting polygons will have their positions interpolated according to the normals of the source vertices, turning the 'fake' surfaces of normal interpolation into true geometry. This can produce smoother looking results, but it's usually unnecessary.

![isomesh1](https://user-images.githubusercontent.com/18707147/115974173-d686ec80-a552-11eb-8308-87ddec99cd16.png)


## Project Structure
In this project, you'll find two scenes: one for mesh generation and one for raymarching. Both have very similar structures are just meant to show how to use the tools.

SDFs are divided into two different components: SDFPrimitives and SDFMeshes. The SDFPrimitive component is standalone and can only currently represent four objects: a sphere, a (rounded) cuboid, a torus, and a box frame. SDFMeshes provide a reference to an SDFMeshAsset file generated by the Mesh to SDF tool. these objects behave much as you'd expect from a Unity GameObject: you can move them around, rotate them, etc. These objects can be set to either 'min' or 'subtract' - min (minimum) objects will combine with others, subtract objects will 'cut holes' in all the objects above them in the hierarchy. For now these are the only SDF primitives and operations I've added, [but there are many more.](https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm)

You'll always have an 'SDFGroup' as the parent of everything within your 'system' of sdf meshes and primitives. Objects within this system are expected to interact with one another and share the same visual properties such as colour and texture.

The final essential element is a SDFGroupRaymarcher or SDFGroupMeshGenerator. You can have as many of these as you want under one group. SDFGroupMeshGenerators can even represent 'chunks' - though they need to overlap by the size of one cell on all sides, and should have all the same settings.

## Isosurface Extraction
An 'isosurface' is the bits of a scalar field which all have the same values. In SDFs, the isosurface is simply the points where the distance to the surface is zero.

Isosurface extraction here refers to converting an isosurface back into a triangle mesh. There are many different algorithms for isosurface extraction, perhaps the most well known being the 'marching cubes' algorithm. In this project, I implemented two (very similar) isosurface extraction algorithms: surface nets and dual contouring. I won't go into any more detail on these algorithms here, [as others have already explained them very well.](https://www.boristhebrave.com/2018/04/15/dual-contouring-tutorial/)

As I say above, in order to use the isosurface extraction just add a SDFGroupMeshGenerator under an SDFGroup. The number of options on this component is almost excessive, but don't let that get you down, they all have tooltips which do some explaining, and if you've done your homework they should feel fairly familiarly:

![isomesh3](https://user-images.githubusercontent.com/18707147/115974664-1a2f2580-a556-11eb-83f0-c51895dd9d52.png)

Normal settings are handy to control the appearance of the mesh surface. 'Max angle tolerance' will generate new mesh vertices when normals are too distinct from the nomral of their triangle. I like to keep this value around 40 degrees, as it retains sharp edges while keeping smooth curves. 'Visual smoothing' changes the distance between samples when generating mesh normals via central differences.

![isomesh4](https://user-images.githubusercontent.com/18707147/115974786-21a2fe80-a557-11eb-84a0-62c28b537501.png)

There are some additions I've made to try to improve the results of dual contouring. While it produces good edges and corners, QEF can sometimes be a little unstable. I provide optional direct control over the QEF (quadratic error function) constants. I provide two techniques for finding the exact surface intersection points between SDF samples - interpolation is fast but gives kinda poor results at corners. Binary search provides much more exact results but is an iterative solution.

Gradient descent is another iterative improvement which simply moves the vertices back onto the isosurface. Honestly, I see no reason not to always have this on.

The 'nudge' stuff is an experimental solution for reducing artefacts on mesh edges and corners. It moves the mesh vertices a tiny bit in the direction of the sum of the normals at the voxel edge intersections. By itself, this simply 'inflates' the mesh. But alongside gradient descent, it can produce tasty sharp edges, but introduces artefacts of its own. I recommend keeping this value very low if you do use it.

### A note on 'output mode'
You may notice there is an option to switch between 'Procedural' and 'Mesh Filter' output modes. This changes how the mesh data is handed over to Unity for rendering. The 'Mesh Filter' mode simply drags the mesh data back onto the CPU and passes it in to a Mesh Filter component. Procedural mode is waaaay faster - using Unity's DrawProceduralIndirect to keep the data GPU-side. However, you will need a material which is capable of rendering geometry passed in via ComputeBuffers. This project is in URP, which makes it a bit of a pain to hand-write shaders, [and Unity's ShaderGraph doesn't currently support this.](https://forum.unity.com/threads/graphicsbuffer-mesh-vertices-and-compute-shaders.777548/) In my own project, I use Amplify Shader Editor. While I obviously can't include that, I do include the custom node: 'AmplifyNode.hlsl'. Hopefully the feature comes to ShaderGraph soon!

I'll probably want to make these generated meshes interact physically in the future anyway, which will unfortunately require the meshes on the CPU side too.

## Raymarching
If you're familiar with SDFs, you're familiar with Raymarching. They very often go hand-in-hand. Raymarching will also be very familiar to you if you ever go
